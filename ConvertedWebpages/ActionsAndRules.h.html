<DOCTYPE !HTML>
<html>
  <head>
    <Title>ActionsAndRules.h</Title>
    <script src="script.js"></script>
    <link rel="stylesheet" type="text/css" href="style.css">
  </head>

  <body>
    <span class="absolute">
      <label><input type="checkbox" id ="hideF" value="hidefuncs" checked="true" onclick="toggleVisibility('function')">Functions</label><br>
      <label><input type="checkbox" id ="hideC" value="hideclass" checked="true" onclick="toggleVisibility('class')">Classes</label><br>
      <label><input type="checkbox" id ="hidec" value="hidecomms" checked="true" onclick="toggleVisibility('comment')">Comments</label><br>
    </span>
    <h3>Dependencies: 
      <a href=".html"></a>
      <a href="ActionsAndRules.cpp.html">ActionsAndRules.cpp</a>
      <a href="AbstrSynTree.h.html">AbstrSynTree.h</a>
    </h3>    <pre>
#ifndef ACTIONSANDRULES_H
#define ACTIONSANDRULES_H
<span class="comment">/////////////////////////////////////////////////////////////////////
//  ActionsAndRules.h - declares new parsing rules and actions     //
//  ver 3.5                                                        //
//  Language:      Visual C++ 2008, SP1                            //
//  Platform:      Dell Precision T7400, Vista Ultimate SP1        //
//  Application:   Prototype for CSE687 Pr1, Sp09                  //
//  Author:        Jim Fawcett, CST 4-187, Syracuse University     //
//                 (315) 443-3948, jfawcett@twcny.rr.com           //
/////////////////////////////////////////////////////////////////////
<span class="comment">/*
</span>  Module Operations: 
  ==================
  This module defines several action classes.  Its classes provide 
  specialized services needed for specific applications.  The modules
  Parser, Semiression, and Tokenizer, are intended to be reusable
  without change.  This module provides a place to put extensions of
  these facilities and is not expected to be reusable. 

  Required files
  ==============
    - Parser.h, Parser.cpp, ScopeStack.h, ScopeStack.cpp,
      ActionsAndRules.h, ActionsAndRules.cpp, ConfigureParser.cpp,
      ITokenCollection.h, Semiression.h, Semiression.cpp, tokenizer.h, tokenizer.cpp

  Maintenance History:
  ====================
  ver 3.5 : 11 Feb 2019
  - small changes spread over many of the Rule and Action classes, caused
    by changing the lexical scanner, which forced some changes to the
    scanner's interface (sigh!)
  ver 3.4 : 28 May 2017
  - Added several tests for scopestack size in actions to fix exceptions
    thrown when processing code that won't compile.
  ver 3.3 : 26 Feb 2017
  - Fixed bug in public data analysis with changes to rule CppDeclaration
    and its action HandleCppDeclaration.
  - Fixed a minor bug in name collection for operators.  Won't be important
    for dependency analysis.
  ver 3.2 : 28 Aug 16
  - fixed errors in many rules and actions based on lots of testing
  - cleaned up text, removing comments and improving prologues
  ver 3.1 : 23 Aug 16
  - qualified input pointers in rules and actions as const
  - cleaned up code by removing unreachables and commented code, and by simplifying 
  ver 3.0 : 06 Aug 16
  - Added use of AbstrSynTree
  - Added new rules and actions
  - Renamed and modified most of the other actions and rules
  ver 2.1 : 15 Feb 16
  - small functional change to a few of the actions changes display strategy
  - preface the (new) Toker and Semi with Lexer namespace
  ver 2.0 : 01 Jun 11
  - added processing on way to building strong code analyzer
  ver 1.1 : 17 Jan 09
  - changed to accept a pointer to interfaced ITokenCollection instead
    of a Semiression
  ver 1.0 : 12 Jan 06
  - first release

  Planned Changes:
  ================
  C++ lambda detection needs strengthening
*/</span>
<span class="comment">//
</span>#include &lt;queue&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include "Parser.h"
#include "../GrammarHelpers/GrammarHelpers.h"
#include "../SemiExpression/ITokenCollection.h"
#include "../ScopeStack/ScopeStack.h"
#include "../Tokenizer/Toker.h"
#include "../SemiExpression/Semi.h"
#include "../AbstractSyntaxTree/AbstrSynTree.h"
#include "../Logger/Logger.h"
#include "../FileSystem/FileSystem.h"

namespace CodeAnalysis
{  
  <span class="comment">///////////////////////////////////////////////////////////////////
  // Repository instance is used to share resources
  // among all actions.
</span>
  enum Language { C <span class="comment">/* not implemented */</span>, Cpp, CSharp };

  class Repository  <span class="comment">// application specific
</span>  <span class="class">{
  public:
    using Rslt = Logging::StaticLogger&lt;0&gt;;  <span class="comment">// use for application results
    using Demo = Logging::StaticLogger&lt;1&gt;;  // use for demonstrations of processing
    using Dbug = Logging::StaticLogger&lt;2&gt;;  // use for debug output
</span>    using Package = std::string;
    using Path = std::string;

  private:
    Language language_ = Language::Cpp;
    Path path_;
    ScopeStack&lt;ASTNode*&gt; stack;
    AbstrSynTree ast;
    ASTNode* pGlobalScope;
    Package package_;
    Lexer::Toker* p_Toker;
    Access currentAccess_ = Access::publ;
    static Repository* instance;
  
  public:
    
    Repository(Lexer::Toker* pToker) : ast(stack)
    <span class="function">{
      p_Toker = pToker;
      pGlobalScope = stack.top();  <span class="comment">// installed in AST constructor
</span>      instance = this;
    }</span>

    ~Repository()
    <span class="function">{
      Dbug::write("\n  deleting repository");
    }</span>

    Language& language() <span class="function">{ return language_; }</span>

    Package& package() <span class="function">{ return package_; }</span>

    Path& currentPath() <span class="function">{ return path_; }</span>

    Access& currentAccess() <span class="function">{ return currentAccess_; }</span>

    static Repository* getInstance() <span class="function">{ return instance; }</span>

    ScopeStack&lt;ASTNode*&gt;& scopeStack() <span class="function">{ return stack; }</span>

    AbstrSynTree& AST() <span class="function">{ return ast; }</span>

    ASTNode* getGlobalScope() <span class="function">{ return pGlobalScope; }</span>

    Lexer::Toker* Toker() <span class="function">{ return p_Toker; }</span>

    size_t lineCount() 
    <span class="function">{ 
      return (size_t)(p_Toker-&gt;lineCount()); 
    }</span>
  };

  <span class="comment">///////////////////////////////////////////////////////////////
  // rule to detect beginning of scope
</span>
  class BeginScope : public IRule
  <span class="class">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Test begin scope", *pTc);

      <span class="comment">// don't parse Semi with single semicolon token
</span>
      if (pTc-&gt;size() == 1 && (*pTc)[0] == ";")
        return IRule::Stop;

      if (pTc-&gt;contains("{"))
      {
        doActions(pTc);
      }
      return IRule::Continue;
    }</span>
  };

  <span class="comment">///////////////////////////////////////////////////////////////
  // action to handle scope stack at beginning of scope
</span>
  class HandleBeginScope : public IAction
  <span class="class">{
    Repository* p_Repos;
  public:
    HandleBeginScope(Repository* pRepos)
    <span class="function">{
      p_Repos = pRepos;
    }</span>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("handle begin scope", *pTc);

      ASTNode* pElem = new ASTNode;
      pElem-&gt;type_ = "anonymous";
      pElem-&gt;name_ = "none";
      pElem-&gt;package_ = p_Repos-&gt;package();
      pElem-&gt;startLineCount_ = p_Repos-&gt;lineCount();
      pElem-&gt;endLineCount_ = 1;
      pElem-&gt;path_ = p_Repos-&gt;currentPath();
      <span class="comment">/*
       * make this ASTNode child of ASTNode on stack top
       * then push onto stack
       */</span>
      p_Repos-&gt;AST().add(pElem);
    }</span>
  };

  <span class="comment">///////////////////////////////////////////////////////////////
  // rule to detect end of scope
</span>
  class EndScope : public IRule
  <span class="class">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Test end scope", *pTc);

      size_t posCloseBrace;
      pTc-&gt;find("}", posCloseBrace);
      if (posCloseBrace &lt; pTc-&gt;size())
      {
        doActions(pTc);
        return IRule::Stop;
      }
      return IRule::Continue;
    }</span>
  };

  <span class="comment">///////////////////////////////////////////////////////////////
  // action to handle scope stack at end of scope
</span>
  class HandleEndScope : public IAction
  <span class="class">{
    Repository* p_Repos;
  public:
    using Dbug = Logging::StaticLogger&lt;2&gt;;

    HandleEndScope(Repository* pRepos)
    <span class="function">{
      p_Repos = pRepos;
    }</span>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Handle end scope", *pTc);

      if (p_Repos-&gt;scopeStack().size() == 0)
        return;

      ASTNode* pElem = p_Repos-&gt;AST().pop();
      if (pElem == nullptr)
        return;

      pElem-&gt;endLineCount_ = p_Repos-&gt;lineCount();
      if (pElem-&gt;type_ == "class" || pElem-&gt;type_ == "struct")
        (pElem-&gt;endLineCount_)++;

      p_Repos-&gt;currentAccess() = Access::priv;
    }</span>
  };

  <span class="comment">///////////////////////////////////////////////////////////////
  // rule to detect access for C++
</span>
  class DetectAccessSpecifier : public IRule
  <span class="class">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Test access spec", *pTc);

      Repository* pRepo = Repository::getInstance();
      if (pRepo-&gt;language() != Language::Cpp)
        return IRule::Continue;

      size_t pos;
      pTc-&gt;find(":", pos);
      if (0 &lt; pos && pos &lt; pTc-&gt;size())
      {
        const std::string tok = (*pTc)[pos - 1];
        if (tok == "public" || tok == "protected" || tok == "private")
        {
          doActions(pTc);
          return IRule::Stop;
        }
      }
      return IRule::Continue;
    }</span>
  };

  <span class="comment">///////////////////////////////////////////////////////////////
  // action to handle access specifier
</span>
  class HandleAccessSpecifier : public IAction
  <span class="class">{
    Repository* p_Repos;

  public:
    HandleAccessSpecifier(Repository* pRepos)
    <span class="function">{
      p_Repos = pRepos;
    }</span>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Handle access spec: ", *pTc);

      std::string tok = (*pTc)[pTc-&gt;size() - 2];
      Access& access = p_Repos-&gt;currentAccess();
      if (tok == "public")
        access = Access::publ;
      else if (tok == "protected")
        access = Access::prot;
      else
        access = Access::priv;
    }</span>
  };

  <span class="comment">///////////////////////////////////////////////////////////////
  // rule to detect preprocessor statements
</span>
  class PreprocStatement : public IRule
  <span class="class">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Test preproc statement: ", *pTc);

      size_t pPos;
      pTc-&gt;find("#", pPos);
      if (pPos &lt; pTc-&gt;size())
      {
        doActions(pTc);
        return IRule::Stop;
      }
      return IRule::Continue;
    }</span>
  };

  <span class="comment">///////////////////////////////////////////////////////////////
  // action to add Semi to scope stack top statements_
</span>
  class HandlePreprocStatement : public IAction
  <span class="class">{
    Repository* p_Repos;

  public:
    HandlePreprocStatement(Repository* pRepos)
    <span class="function">{
      p_Repos = pRepos;
    }</span>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Handle preproc statement: ", *pTc);

      Lexer::ITokenCollection* pClone = pTc-&gt;clone();
      if (p_Repos-&gt;scopeStack().size() == 0)
        return;
      ASTNode* pElem = p_Repos-&gt;scopeStack().top();
      pElem-&gt;statements_.push_back(pClone);

      GrammarHelper::showParse("Preproc Stmt", *pTc);
    }</span>
  };

  <span class="comment">///////////////////////////////////////////////////////////////
  // rule to detect namespace statements
</span>
  class NamespaceDefinition : public IRule
  <span class="class">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Test namespace definition: ", *pTc);

      const Lexer::ITokenCollection& tc = *pTc;
      if (tc[tc.size() - 1] == "{")
      {
        size_t len;
        tc.find("namespace", len);
        if (len &lt; tc.size())
        {
          doActions(pTc);
          return IRule::Stop;
        }
      }
      return IRule::Continue;
    }</span>
  };

  <span class="comment">///////////////////////////////////////////////////////////////
  // action to add namespace info to scope stack top
</span>
  class HandleNamespaceDefinition : public IAction
  <span class="class">{
    Repository* p_Repos;

  public:
    HandleNamespaceDefinition(Repository* pRepos)
    <span class="function">{
      p_Repos = pRepos;
    }</span>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Handle namespace definition: ", *pTc);

      if (p_Repos-&gt;scopeStack().size() == 0)
        return;

      ASTNode* top = p_Repos-&gt;scopeStack().top();

      size_t pos;
      pTc-&gt;find("namespace", pos);
      std::string name = (*pTc)[pos + 1];
      top-&gt;type_ = "namespace";
      top-&gt;name_ = name;
      top-&gt;package_ = p_Repos-&gt;package();

      GrammarHelper::showParse("namespace def", *pTc);
    }</span>
  };

  <span class="comment">///////////////////////////////////////////////////////////////
  // rule to detect class statements
</span>
  class ClassDefinition : public IRule
  <span class="class">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Test class definition: ", *pTc);

      const Lexer::ITokenCollection& tc = *pTc;
      if (tc[tc.size() - 1] == "{")
      {
        size_t len;
        tc.find("class", len);
        if (len &lt; tc.size())
        {
          doActions(pTc);
          return IRule::Stop;
        }
        if (tc.contains("interface"))
        {
          doActions(pTc);
          return IRule::Stop;
        }
      }
      return IRule::Continue;
    }</span>
  };

  <span class="comment">///////////////////////////////////////////////////////////////
  // action to add class info to scope stack top
</span>
  class HandleClassDefinition : public IAction
  <span class="class">{
    Repository* p_Repos;

  public:
    HandleClassDefinition(Repository* pRepos)
    <span class="function">{
      p_Repos = pRepos;
    }</span>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Handle class definition: ", *pTc);

      p_Repos-&gt;currentAccess() = Access::priv;

      if (p_Repos-&gt;scopeStack().size() == 0)
        return;

      ASTNode* top = p_Repos-&gt;scopeStack().top();
      size_t typeIndex;
      pTc-&gt;find("class", typeIndex);
      if (typeIndex &lt; pTc-&gt;size())
      {
        size_t nameIndex = typeIndex + 1;
        std::string name = (*pTc)[nameIndex];
        top-&gt;type_ = "class";
        top-&gt;name_ = name;
        top-&gt;package_ = p_Repos-&gt;package();
        p_Repos-&gt;AST().typeMap()[name] = top;
        GrammarHelper::showParse("class def", *pTc);
      }
      else  <span class="comment">// C#
</span>      {
        pTc-&gt;find("interface", typeIndex);
        size_t nameIndex = typeIndex + 1;
        std::string name = (*pTc)[nameIndex];
        top-&gt;type_ = "interface";
        top-&gt;name_ = name;
        top-&gt;package_ = p_Repos-&gt;package();
        p_Repos-&gt;AST().typeMap()[name] = top;
        GrammarHelper::showParse("interface def", *pTc);
      }
    }</span>
  };

  <span class="comment">///////////////////////////////////////////////////////////////
  // rule to detect struct statements
</span>
  class StructDefinition : public IRule
  <span class="class">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Test struct definition: ", *pTc);

      const Lexer::ITokenCollection& tc = *pTc;
      if (tc[tc.size() - 1] == "{")
      {
        size_t len;
        tc.find("struct", len);
        if (len &lt; tc.size())
        {
          doActions(pTc);
          return IRule::Stop;
        }
      }
      return IRule::Continue;
    }</span>
  };

  <span class="comment">///////////////////////////////////////////////////////////////
  // action to add struct info to scope stack top
</span>
  class HandleStructDefinition : public IAction
  <span class="class">{
    Repository* p_Repos;

  public:
    HandleStructDefinition(Repository* pRepos)
    <span class="function">{
      p_Repos = pRepos;
    }</span>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Handle struct definition: ", *pTc);

      p_Repos-&gt;currentAccess() = Access::publ;

      if (p_Repos-&gt;scopeStack().size() == 0)
        return;

      ASTNode* top = p_Repos-&gt;scopeStack().top();

      size_t pos;
      pTc-&gt;find("struct", pos);
      std::string name = (*pTc)[pos + 1];
      top-&gt;type_ = "struct";
      top-&gt;name_ = name;
      top-&gt;package_ = p_Repos-&gt;package();
      p_Repos-&gt;AST().typeMap()[name] = top;

      GrammarHelper::showParse("struct def", *pTc);
    }</span>
  };

  <span class="comment">///////////////////////////////////////////////////////////////
  // rule to detect C++ function definitions
</span>
  class CppFunctionDefinition : public IRule
  <span class="class">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      Repository* pRepo = Repository::getInstance();
      if (pRepo-&gt;language() != Language::Cpp)
        return IRule::Continue;

      GrammarHelper::showParseDemo("Test C++ function definition: ", *pTc);

      ScopeStack&lt;ASTNode*&gt;& stack = pRepo-&gt;scopeStack();
      if (stack.size() &lt; 2)
        return IRule::Continue;

      std::string parentType = stack.predOfTop()-&gt;type_;
      if (parentType != "namespace" && parentType != "class" && parentType != "struct")
        return IRule::Continue;

      const Lexer::ITokenCollection& tc = *pTc;

      if (tc[tc.size() - 1] == "{")
      {
        if (GrammarHelper::isFunction(*pTc))
        {
          doActions(pTc);
          return IRule::Stop;
        }
      }
      return IRule::Continue;
    }</span>
  };

  <span class="comment">///////////////////////////////////////////////////////////////
  // action to add function info to scope stack top
</span>
  class HandleCppFunctionDefinition : public IAction
  <span class="class">{
    Repository* p_Repos;

  public:
    HandleCppFunctionDefinition(Repository* pRepos)
    <span class="function">{
      p_Repos = pRepos;
    }</span>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Handle C++ function definition: ", *pTc);

      ScopeStack&lt;ASTNode*&gt;& stack = p_Repos-&gt;scopeStack();
     
      if (stack.size() == 0)
        return;

      ASTNode* top = stack.top();

      size_t nameIndex;
      if(pTc-&gt;find("(", nameIndex))
      --nameIndex;
      else return;
      std::string name = (*pTc)[nameIndex];

      <span class="comment">// is function a destructor?
</span>
      if (nameIndex &gt; 0 && (*pTc)[nameIndex - 1] == "~")
      {
        --nameIndex;
        name = "~" + name;
      }

      top-&gt;type_ = "function";
      top-&gt;name_ = name;
      top-&gt;package_ = p_Repos-&gt;package();
      GrammarHelper::showParse("function def", *pTc);

      <span class="comment">// is function an operator?
</span>
      size_t operIndex;
      pTc-&gt;find("operator", operIndex);
      if (operIndex &lt; pTc-&gt;size())
      {
        name = "operator" + (*pTc)[operIndex + 1];<span class="comment">// +(*pTc)[operIndex + 2];
</span>        if ((*pTc)[operIndex + 2] != "(")
          name += (*pTc)[operIndex + 2];
        top-&gt;name_ = name;
        nameIndex = operIndex;
      }
      <span class="comment">// is function a member of a class or struct?
</span>
      if (nameIndex &gt; 1 && (*pTc)[nameIndex - 1] == "::")
      {
        <span class="comment">//----&lt; start find class name &gt;--------------------
</span>
        std::string className = (*pTc)[nameIndex - 2];

        <span class="comment">// is class a template?
</span>
        if (className == "&gt;")
        {
          size_t startParam = GrammarHelper::findLast(*pTc, "&lt;");
          if (0 &lt; startParam && startParam &lt; pTc-&gt;size())
            className = (*pTc)[startParam - 1];
        }
        <span class="comment">//----&lt; end find class name &gt;----------------------
        <span class="comment">/*
</span>        * - this function's ASTNode is at stack top
        * - find ASTNode of function's class
        * - unlink function ASTNode from stack top predecessor
        * - relink function ASTNode to it's class ASTNode
        * - leave function ASTNode on stack top as it may have child nodes
        */</span>
        ASTNode* pClassNode = p_Repos-&gt;AST().find(className);
        if (pClassNode == nullptr)
          return;
        if (p_Repos-&gt;scopeStack().size() &lt; 2)
          return;

        ASTNode* pFunctNode = p_Repos-&gt;scopeStack().top();
        ASTNode* pParentNode = p_Repos-&gt;scopeStack().predOfTop();
        if(pParentNode-&gt;children_.size() &gt; 0)
          pParentNode-&gt;children_.pop_back();           <span class="comment">// unlink function
</span>        pFunctNode-&gt;parentType_ = pClassNode-&gt;type_;
        pClassNode-&gt;children_.push_back(pFunctNode);   <span class="comment">// relink function
</span>        return;
      }
      <span class="comment">// is this a lambda?
</span>
      std::string packageName = p_Repos-&gt;package();
      std::string ext = FileSystem::Path::getExt(packageName);

      size_t posOpenBracket;
      pTc-&gt;find("[", posOpenBracket);
      size_t posCloseBracket;
      pTc-&gt;find("]", posCloseBracket);
      size_t posBrace;
      pTc-&gt;find("{", posBrace);
      size_t posOpenParen;
      pTc-&gt;find("(", posOpenParen);
      if (posCloseBracket != posBrace + 1 && posCloseBracket != posOpenParen + 1) <span class="comment">// []{ or [](
</span>        return;
      if (posOpenBracket &lt; posCloseBracket && posBrace == (posCloseBracket + 1) && posBrace &lt; pTc-&gt;size())
      {
        std::string name;
        for (size_t i = posOpenBracket; i &lt; posBrace; ++i)
          name += (*pTc)[i];
        top-&gt;name_ = name;
        top-&gt;type_ = "lambda";
      }
    }</span>
  };

  <span class="comment">///////////////////////////////////////////////////////////////
  // rule to detect C# function definitions
</span>
  class CSharpFunctionDefinition : public IRule
  <span class="class">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      Repository* pRepo = Repository::getInstance();
      if (pRepo-&gt;language() != Language::CSharp)
        return IRule::Continue;

      GrammarHelper::showParseDemo("Test C# function definition: ", *pTc);

      const Lexer::ITokenCollection& tc = *pTc;
      if (tc[tc.size() - 1] == "{")
      {
        Lexer::Semi se;
        for (size_t i = 0; i &lt; tc.size(); ++i)
          se.add(tc[i]);

        if (GrammarHelper::isFunction(se))
        {
          doActions(&se);
          return IRule::Stop;
        }
      }
      return IRule::Continue;
    }</span>
  };

  <span class="comment">///////////////////////////////////////////////////////////////
  // action to add function info to scope stack top
</span>
  class HandleCSharpFunctionDefinition : public IAction
  <span class="class">{
    Repository* p_Repos;

  public:
    HandleCSharpFunctionDefinition(Repository* pRepos)
    <span class="function">{
      p_Repos = pRepos;
    }</span>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Handle C# function definition: ", *pTc);

      if (p_Repos-&gt;scopeStack().size() == 0)
        return;

      ASTNode* top = p_Repos-&gt;scopeStack().top();

      size_t nameIndex;
      if (pTc-&gt;find("(", nameIndex))
        --nameIndex;
      else
        return;

      std::string name = (*pTc)[nameIndex];

      <span class="comment">// is function a destructor?
</span>
      if (nameIndex &gt; 0 && (*pTc)[nameIndex - 1] == "~")
      {
        --nameIndex;
        name = "~" + name;
      }

      top-&gt;type_ = "function";
      top-&gt;name_ = name;
      top-&gt;package_ = p_Repos-&gt;package();

      GrammarHelper::showParse("function def", *pTc);

      <span class="comment">// is function an operator?
</span>
      size_t operIndex;
      pTc-&gt;find("operator", operIndex);
      if (operIndex &lt; pTc-&gt;size())
      {
        name = "operator" + (*pTc)[operIndex + 1] + (*pTc)[operIndex + 2];
        top-&gt;name_ = name;
        nameIndex = operIndex;
      }

      <span class="comment">// is lambda?
</span>
      size_t posParen;
      pTc-&gt;find("(", posParen);
      size_t posBrace;
      pTc-&gt;find("{", posBrace);
      size_t posEqual;
      pTc-&gt;find("=", posEqual);
      if (posParen &lt; posBrace && posBrace &lt; pTc-&gt;size())
      {
        if (posEqual &lt; pTc-&gt;size() - 1 && (*pTc)[posEqual + 1] == "&gt;")
        {
          std::string name;
          for (size_t i = posParen; i &lt;= posBrace; ++i)
            name += (*pTc)[i];
          top-&gt;name_ = name;
          top-&gt;type_ = "lambda";
        }
      }
    }</span>
  };

  <span class="comment">///////////////////////////////////////////////////////////////
  // rule to detect control definitions
</span>
  class ControlDefinition : public IRule
  <span class="class">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Test control definition: ", *pTc);

      const Lexer::ITokenCollection& tc = *pTc;
      if (tc[tc.size() - 1] == "{")
      {
        size_t len;
        tc.find("(", len);
        if (len &lt; tc.size() && GrammarHelper::isControlKeyWord(tc[len - 1]))
        {
          doActions(pTc);
          return IRule::Stop;
        }
        else if (tc.size() &gt; 1 && GrammarHelper::isControlKeyWord(tc[tc.size() - 2]))
        {
          doActions(pTc);
          return IRule::Stop;
        }
      }
      return IRule::Continue;
    }</span>
  };

  <span class="comment">///////////////////////////////////////////////////////////////
  // action to add control info to scope stack top
</span>
  class HandleControlDefinition : public IAction
  <span class="class">{
    Repository* p_Repos;

  public:
    HandleControlDefinition(Repository* pRepos)
    <span class="function">{
      p_Repos = pRepos;
    }</span>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Handle control definition: ", *pTc);

      if (p_Repos-&gt;scopeStack().size() == 0)
        return;

      ASTNode* top;
      if ((p_Repos-&gt;scopeStack()).size() &gt; 0)
        top = p_Repos-&gt;scopeStack().top();
      else
        return;

      size_t nameIndex;
      if(pTc-&gt;find("(", nameIndex))         <span class="comment">// if, for, while, switch, catch
</span>        --nameIndex;
      <span class="comment">//if (nameIndex == pTc-&gt;size() - 1)     // do, try - they don't have parens
</span>      else
        nameIndex = pTc-&gt;size() - 2;
      std::string name = (*pTc)[nameIndex];
      top-&gt;type_ = "control";
      top-&gt;name_ = name;

      GrammarHelper::showParse("control def", *pTc);
    }</span>
  };

  <span class="comment">///////////////////////////////////////////////////////////////
  // action to send semi-expression that starts a function def
  // to console
</span>
  class PrintFunction : public IAction
  <span class="class">{
    Repository* p_Repos;
  public:
    using Rslt = Logging::StaticLogger&lt;0&gt;;

    PrintFunction(Repository* pRepos)
    <span class="function">{
      p_Repos = pRepos;
    }</span>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      std::ostringstream out;
      <span class="comment">//out &lt;&lt; "\n  FuncDef: " &lt;&lt; pTc-&gt;show().c_str();
</span>      Rslt::write(out.str());
    }</span>
  };

  <span class="comment">///////////////////////////////////////////////////////////////
  // action to send signature of a function def to console
</span>
  class PrettyPrintFunction : public IAction
  <span class="class">{
    Repository* p_Repos;
  public:
    using Rslt = Logging::StaticLogger&lt;0&gt;;

    PrettyPrintFunction(Repository* pRepos) : p_Repos(pRepos) <span class="function">{}</span>

    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      size_t len;
      pTc-&gt;find(")", len);

      std::ostringstream out;
      out &lt;&lt; "\n\n  Pretty Stmt:    ";
      for (size_t i = 0; i &lt; len + 1; ++i)
        out &lt;&lt; (*pTc)[i] &lt;&lt; " ";
      out &lt;&lt; "\n";
      Rslt::write(out.str());
    }</span>
  };

  <span class="comment">///////////////////////////////////////////////////////////////
  // rule to detect C++ Declaration
  <span class="comment">/*
</span>  *  - Declaration ends in semicolon
  *  - has type, name, modifiers & initializers
  *  So:
  *  - strip off modifiers and initializers
  *  - if you have two things left it's a declar, else executable
  */</span>
  class CppDeclaration : public IRule
  <span class="class">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      Repository* pRepo = Repository::getInstance();
      if (pRepo-&gt;language() != Language::Cpp)
        return IRule::Continue;

      GrammarHelper::showParseDemo("Test C++ declaration: ", *pTc);

      Lexer::Semi tc;
      tc.clone(*pTc);

      <span class="comment">// begin added 2/26/2017
</span>
      Access access = pRepo-&gt;currentAccess();
      bool isPublic = false;

      if (pRepo-&gt;scopeStack().size() == 0)
        return false;

      std::string parentType = pRepo-&gt;scopeStack().top()-&gt;type_;

      size_t posPrivate;
      pTc-&gt;find("private", posPrivate);
      if (posPrivate &lt; pTc-&gt;size())
      {
        isPublic = false;
        pRepo-&gt;currentAccess() = Access::priv;
      }

      size_t posProtected;
      pTc-&gt;find("protected", posProtected);
      if (posProtected &lt; pTc-&gt;size())
      {
        isPublic = false;
        pRepo-&gt;currentAccess() = Access::prot;
      }

      size_t posPublic;
      pTc-&gt;find("public", posPublic);
      if (posPublic &lt; pTc-&gt;size() && parentType != "function")
      {
        isPublic = true;
        pRepo-&gt;currentAccess() = Access::publ;
      }

      <span class="comment">// end added 2/26/2017
</span>
      if (tc.size() &gt; 0 && tc[0] == "using")
      {
        doActions(pTc);
        return IRule::Stop;
      }

      if (tc[tc.size() - 1] == ";" && tc.size() &gt; 2)
      {
        std::string nextToLast = tc[tc.size() - 2];
        if (nextToLast == "delete" || nextToLast == "default" || nextToLast == "const")
        {
          {
            <span class="comment">// function declaration
</span>            doActions(pTc);
            return IRule::Stop;
          }
        }
        std::string parentType = pRepo-&gt;scopeStack().top()-&gt;type_;
        
        if (GrammarHelper::isDataDeclaration(tc) || GrammarHelper::isFunctionDeclaration(tc, parentType))
        {
          doActions(pTc);
          return IRule::Stop;
        }

        if (parentType != "function")
        {
          <span class="comment">// can't be executable so must be declaration
</span>
          doActions(pTc);
          return IRule::Stop;
        }
      }
      return IRule::Continue;
    }</span>
  };

  <span class="comment">///////////////////////////////////////////////////////////////
  // action to add declaration info to scope stack top
</span>
  class HandleCppDeclaration : public IAction
  <span class="class">{
    Repository* p_Repos;

  public:
    HandleCppDeclaration(Repository* pRepos) : p_Repos(pRepos) <span class="function">{}</span>

    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Handle C++ declaration: ", *pTc);

      <span class="comment">// save declaration info in ASTNode
</span>
      if (p_Repos-&gt;scopeStack().size() == 0)
        return;

      ASTNode* pCurrNode = p_Repos-&gt;scopeStack().top();
      DeclarationNode declNode;
      declNode.access_ = p_Repos-&gt;currentAccess();
      declNode.pTc = pTc-&gt;clone();
      declNode.package_ = p_Repos-&gt;package();
      declNode.line_ = p_Repos-&gt;lineCount();

      Lexer::Semi se;
      se.clone(*pTc);
      GrammarHelper::removeComments(se);

      if (se[0] == "using")
      {
        declNode.declType_ = DeclType::usingDecl;
        pCurrNode-&gt;decl_.push_back(declNode);

        GrammarHelper::showParse("using declar", *pTc);
        return;
      }

      if (GrammarHelper::isFunctionDeclaration(se,"parentNotFunction"))
      {
        return;
      }

      if (GrammarHelper::isDataDeclaration(se))
      {
        declNode.declType_ = DeclType::dataDecl;
        pCurrNode-&gt;decl_.push_back(declNode);
        GrammarHelper::showParse("data declar", *pTc);
      }
    }</span>
  };

  <span class="comment">///////////////////////////////////////////////////////////////
  // rule to detect C# Declaration
  <span class="comment">/*
</span>  *  - Declaration ends in semicolon
  *  - has type, name, modifiers & initializers
  *  So:
  *  - strip of modifiers and initializers
  *  - if you have two things left it's a declar, else executable
  */</span>
  class CSharpDeclaration : public IRule
  <span class="class">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      Repository* pRepo = Repository::getInstance();
      if (pRepo-&gt;language() != Language::CSharp)
        return IRule::Continue;

      GrammarHelper::showParseDemo("Test C# declaration: ", *pTc);

      Access access = pRepo-&gt;currentAccess();
      bool isPublic = false;

      if (pRepo-&gt;scopeStack().size() == 0)
        return false;

      std::string parentType = pRepo-&gt;scopeStack().top()-&gt;type_;

      size_t posPublic;
      pTc-&gt;find("public", posPublic);
      if (posPublic &lt; pTc-&gt;size() && parentType != "function")
      {
        isPublic = true;
        pRepo-&gt;currentAccess() = Access::publ;
      }

      const Lexer::ITokenCollection& tc = *pTc;
      if (tc.size() &gt; 0 && tc[0] == "using")
      {
        doActions(pTc);
        pRepo-&gt;currentAccess() = access;
        return IRule::Stop;
      }

      Lexer::Semi se;
      se.clone(*pTc);

      if (GrammarHelper::isDataDeclaration(se))
      {
        doActions(pTc);
        pRepo-&gt;currentAccess() = access;
        return IRule::Stop;
      }

      if (GrammarHelper::isFunctionDeclaration(se, parentType))
      {
        doActions(pTc);
        pRepo-&gt;currentAccess() = access;
        return IRule::Stop;
      }
      return IRule::Continue;
    }</span>
  };

  <span class="comment">///////////////////////////////////////////////////////////////
  // action to add declaration info to scope stack top
</span>
  class HandleCSharpDeclaration : public IAction
  <span class="class">{
    Repository* p_Repos;

  public:
    HandleCSharpDeclaration(Repository* pRepos) : p_Repos(pRepos) <span class="function">{}</span>

    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Handle C# declaration: ", *pTc);

      <span class="comment">// store declaration info in ASTNode
</span>
      if (p_Repos-&gt;scopeStack().size() == 0)
        return;

      ASTNode* pCurrNode = p_Repos-&gt;scopeStack().top();
      DeclarationNode declNode;
      declNode.access_ = p_Repos-&gt;currentAccess();
      declNode.pTc = pTc-&gt;clone();
      declNode.package_ = p_Repos-&gt;package();
      declNode.line_ = p_Repos-&gt;lineCount();

      Lexer::Semi se;
      se.clone(*pTc);
      GrammarHelper::removeComments(se);

      if (se[0] == "using")
      {
        declNode.declType_ = DeclType::usingDecl;
        pCurrNode-&gt;decl_.push_back(declNode);

        GrammarHelper::showParse("using declar", *pTc);
        return;
      }

      std::string parentType = p_Repos-&gt;scopeStack().top()-&gt;type_;

      if (GrammarHelper::isFunctionDeclaration(se, parentType))
      {
        Access adebug = declNode.access_;
        declNode.declType_ = DeclType::functionDecl;
        pCurrNode-&gt;decl_.push_back(declNode);
        GrammarHelper::showParse("function declar", *pTc);
      }
      else
      {
        Access adebug = declNode.access_;
        declNode.declType_ = DeclType::dataDecl;
        pCurrNode-&gt;decl_.push_back(declNode);
        GrammarHelper::showParse("data declar", *pTc);
      }
    }</span>
  };

  <span class="comment">///////////////////////////////////////////////////////////////
  // rule to detect C++ Executable
</span>
  class CppExecutable : public IRule
  <span class="class">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      Repository* pRepo = Repository::getInstance();
      if (pRepo-&gt;language() != Language::Cpp)
        return IRule::Continue;

      GrammarHelper::showParseDemo("Test C++ executable: ", *pTc);

      Lexer::Semi tc;
      tc.clone(*pTc);

      if (tc[tc.size() - 1] == ";" && tc.size() &gt; 2)
      {
        GrammarHelper::removeFunctionArgs(tc);
        GrammarHelper::condenseTemplateTypes(tc);

        <span class="comment">// remove modifiers, comments, newlines, returns, and initializers
</span>
        Lexer::Semi se;
        for (size_t i = 0; i &lt; tc.size(); ++i)
        {
          if (GrammarHelper::isQualifierKeyWord(tc[i]))
            continue;
          if (se.isComment(tc[i]) || tc[i] == "\n" || tc[i] == "return")
            continue;
          if (tc[i] == "=" || tc[i] == ";")
          {
            se.add(";");
            break;
          }
          else
            se.add(tc[i]);
        }
        if (se.size() != 3)  <span class="comment">// not a declaration
</span>        {
          doActions(pTc);
          return IRule::Stop;
        }
      }
      return IRule::Continue;
    }</span>
  };

  <span class="comment">///////////////////////////////////////////////////////////////
  // action to display C++ executable info
</span>
  class HandleCppExecutable : public IAction
  <span class="class">{
    Repository* p_Repo;

  public:
    HandleCppExecutable(Repository* pRepo) : p_Repo(pRepo) <span class="function">{}</span>

    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Handle C++ executable: ", *pTc);

      GrammarHelper::showParse("executable", *pTc);
    }</span>
  };
  <span class="comment">///////////////////////////////////////////////////////////////
  // rule to detect C# Executable
</span>
  class CSharpExecutable : public IRule
  <span class="class">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      Repository* pRepo = Repository::getInstance();
      if (pRepo-&gt;language() != Language::CSharp)
        return IRule::Continue;

      GrammarHelper::showParseDemo("Test C# executable: ", *pTc);

      const Lexer::ITokenCollection& in = *pTc;
      Lexer::Semi tc;
      for (size_t i = 0; i &lt; in.size(); ++i)
        tc.add(in[i]);

      if (tc[tc.size() - 1] == ";" && tc.size() &gt; 2)
      {
        GrammarHelper::removeFunctionArgs(tc);
        GrammarHelper::condenseTemplateTypes(tc);

        <span class="comment">// remove modifiers, comments, newlines, returns, and initializers
</span>
        Lexer::Semi se;
        for (size_t i = 0; i &lt; tc.size(); ++i)
        {
          if (GrammarHelper::isQualifierKeyWord(tc[i]))
            continue;
          if (se.isComment(tc[i]) || tc[i] == "\n" || tc[i] == "return")
            continue;
          if (tc[i] == "=" || tc[i] == ";")
          {
            se.add(";");
            break;
          }
          else
            se.add(tc[i]);
        }
        if (se.size() != 3)  <span class="comment">// not a declaration
</span>        {
          doActions(pTc);
          return IRule::Stop;
        }
      }
      return IRule::Continue;
    }</span>
  };
  <span class="comment">///////////////////////////////////////////////////////////////
  // action to display C# executable info
</span>
  class HandleCSharpExecutable : public IAction
  <span class="class">{
    Repository* p_Repo;

  public:
    HandleCSharpExecutable(Repository* pRepo) : p_Repo(pRepo) <span class="function">{}</span>

    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Handle C# executable: ", *pTc);

      Lexer::Semi se;
      se.clone(*pTc);
      GrammarHelper::removeComments(se);

      GrammarHelper::showParse("executable", se);
    }</span>
  };
  <span class="comment">///////////////////////////////////////////////////////////////
  // default rule
  // - this is here to catch any Semi that didn't parse
  // - We don't have rule for enums, so they are caugth here
</span>
  class Default : public IRule
  <span class="class">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Test default: ", *pTc);

      doActions(pTc);  <span class="comment">// catches everything
</span>      return IRule::Stop;
    }</span>
  };
  <span class="comment">///////////////////////////////////////////////////////////////
  // action to display default info
</span>
  class HandleDefault : public IAction
  <span class="class">{
    Repository* p_Repo;

  public:
    HandleDefault(Repository* pRepo) : p_Repo(pRepo) <span class="function">{}</span>

    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Handle default: ", *pTc);
      GrammarHelper::showParse("default: ", *pTc);
    }</span>
  };
}</span>
#endif
    </pre>
  </body>
</html>
